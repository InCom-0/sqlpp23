#pragma once

// generated by ./scripts/ddl2cpp -auto-id -with-table-creation-helper
// tests/include/sqlpp11/tests/postgresql/tables.sql
// tests/include/sqlpp11/tests/postgresql/tables test

#include <optional>

#include <sqlpp11/core/basic/table.h>
#include <sqlpp11/core/basic/table_columns.h>
#include <sqlpp11/core/name/create_name_tag.h>
#include <sqlpp11/core/type_traits.h>

namespace test {
template <typename Db> void createTabFoo(Db &db) {
  db.execute(R"+++(DROP TABLE IF EXISTS tab_foo)+++");
  db.execute(R"+++(CREATE TABLE tab_foo
(
  id bigserial PRIMARY KEY,
  text_nn_d varchar(255) NOT NULL DEFAULT '',
  int_n bigint,
  double_n double precision,
  bool_n bool,
  blob_n bytea
))+++");
}

struct TabFoo_ : public ::sqlpp::name_tag_base {
  struct Id : public ::sqlpp::name_tag_base {
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(id, id);
    using value_type = ::sqlpp::integral;
    using has_default = std::true_type;
  };
  struct TextNnD : public ::sqlpp::name_tag_base {
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(text_nn_d, textNnD);
    using value_type = ::sqlpp::text;
    using has_default = std::true_type;
  };
  struct IntN : public ::sqlpp::name_tag_base {
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(int_n, intN);
    using value_type = std::optional<::sqlpp::integral>;
    using has_default = std::true_type;
  };
  struct DoubleN : public ::sqlpp::name_tag_base {
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(double_n, doubleN);
    using value_type = std::optional<::sqlpp::floating_point>;
    using has_default = std::true_type;
  };
  struct BoolN : public ::sqlpp::name_tag_base {
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(bool_n, boolN);
    using value_type = std::optional<::sqlpp::boolean>;
    using has_default = std::true_type;
  };
  struct BlobN : public ::sqlpp::name_tag_base {
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(blob_n, blobN);
    using value_type = std::optional<::sqlpp::blob>;
    using has_default = std::true_type;
  };
  SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(tab_foo, tabFoo);
  template <typename T>
  using _table_columns =
      sqlpp::table_columns<T, Id, TextNnD, IntN, DoubleN, BoolN, BlobN>;
  using _required_insert_columns = sqlpp::detail::type_set<>;
};
using TabFoo = ::sqlpp::table_t<TabFoo_>;

template <typename Db> void createTabBar(Db &db) {
  db.execute(R"+++(DROP TABLE IF EXISTS tab_bar)+++");
  db.execute(R"+++(CREATE TABLE tab_bar
(
  id bigserial PRIMARY KEY,
  text_n varchar(255) NULL,
  bool_nn bool NOT NULL DEFAULT false,
  int_n int
))+++");
}

struct TabBar_ : public ::sqlpp::name_tag_base {
  struct Id : public ::sqlpp::name_tag_base {
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(id, id);
    using value_type = ::sqlpp::integral;
    using has_default = std::true_type;
  };
  struct TextN : public ::sqlpp::name_tag_base {
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(text_n, textN);
    using value_type = std::optional<::sqlpp::text>;
    using has_default = std::true_type;
  };
  struct BoolNn : public ::sqlpp::name_tag_base {
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(bool_nn, boolNn);
    using value_type = ::sqlpp::boolean;
    using has_default = std::true_type;
  };
  struct IntN : public ::sqlpp::name_tag_base {
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(int_n, intN);
    using value_type = std::optional<::sqlpp::integral>;
    using has_default = std::true_type;
  };
  SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(tab_bar, tabBar);
  template <typename T>
  using _table_columns = sqlpp::table_columns<T, Id, TextN, BoolNn, IntN>;
  using _required_insert_columns = sqlpp::detail::type_set<>;
};
using TabBar = ::sqlpp::table_t<TabBar_>;

template <typename Db> void createTabDateTime(Db &db) {
  db.execute(R"+++(DROP TABLE IF EXISTS tab_date_time)+++");
  db.execute(R"+++(CREATE TABLE tab_date_time
(
  day_point_n date,
  time_point_n timestamp,
  time_of_day_n time,
  time_point_n_tz timestamp with time zone,
  time_of_day_n_tz time with time zone
))+++");
}

struct TabDateTime_ : public ::sqlpp::name_tag_base {
  struct DayPointN : public ::sqlpp::name_tag_base {
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(day_point_n, dayPointN);
    using value_type = std::optional<::sqlpp::day_point>;
    using has_default = std::true_type;
  };
  struct TimePointN : public ::sqlpp::name_tag_base {
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(time_point_n, timePointN);
    using value_type = std::optional<::sqlpp::time_point>;
    using has_default = std::true_type;
  };
  struct TimeOfDayN : public ::sqlpp::name_tag_base {
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(time_of_day_n, timeOfDayN);
    using value_type = std::optional<::sqlpp::time_of_day>;
    using has_default = std::true_type;
  };
  struct TimePointNTz : public ::sqlpp::name_tag_base {
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(time_point_n_tz, timePointNTz);
    using value_type = std::optional<::sqlpp::time_point>;
    using has_default = std::true_type;
  };
  struct TimeOfDayNTz : public ::sqlpp::name_tag_base {
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(time_of_day_n_tz, timeOfDayNTz);
    using value_type = std::optional<::sqlpp::time_of_day>;
    using has_default = std::true_type;
  };
  SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(tab_date_time, tabDateTime);
  template <typename T>
  using _table_columns =
      sqlpp::table_columns<T, DayPointN, TimePointN, TimeOfDayN, TimePointNTz,
                           TimeOfDayNTz>;
  using _required_insert_columns = sqlpp::detail::type_set<>;
};
using TabDateTime = ::sqlpp::table_t<TabDateTime_>;

template <typename Db> void createBlobSample(Db &db) {
  db.execute(R"+++(DROP TABLE IF EXISTS blob_sample)+++");
  db.execute(R"+++(CREATE TABLE blob_sample (
  id bigserial PRIMARY KEY,
  data bytea
))+++");
}

struct BlobSample_ : public ::sqlpp::name_tag_base {
  struct Id : public ::sqlpp::name_tag_base {
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(id, id);
    using value_type = ::sqlpp::integral;
    using has_default = std::true_type;
  };
  struct Data : public ::sqlpp::name_tag_base {
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(data, data);
    using value_type = std::optional<::sqlpp::blob>;
    using has_default = std::true_type;
  };
  SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(blob_sample, blobSample);
  template <typename T>
  using _table_columns = sqlpp::table_columns<T, Id, Data>;
  using _required_insert_columns = sqlpp::detail::type_set<>;
};
using BlobSample = ::sqlpp::table_t<BlobSample_>;

template <typename Db> void createTabExcept(Db &db) {
  db.execute(R"+++(DROP TABLE IF EXISTS tab_except)+++");
  db.execute(R"+++(CREATE TABLE tab_except (
  int_small_n_u smallint UNIQUE,
  text_short_n text CHECK( length(text_short_n) < 5 )
))+++");
}

struct TabExcept_ : public ::sqlpp::name_tag_base {
  struct IntSmallNU : public ::sqlpp::name_tag_base {
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(int_small_n_u, intSmallNU);
    using value_type = std::optional<::sqlpp::integral>;
    using has_default = std::true_type;
  };
  struct TextShortN : public ::sqlpp::name_tag_base {
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(text_short_n, textShortN);
    using value_type = std::optional<::sqlpp::text>;
    using has_default = std::true_type;
  };
  SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(tab_except, tabExcept);
  template <typename T>
  using _table_columns = sqlpp::table_columns<T, IntSmallNU, TextShortN>;
  using _required_insert_columns = sqlpp::detail::type_set<>;
};
using TabExcept = ::sqlpp::table_t<TabExcept_>;

} // namespace test
